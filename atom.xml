<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ICEY</title>
  
  <subtitle>ICEY的故事才刚刚开始...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://iceyxiner.github.io/"/>
  <updated>2019-05-24T03:19:27.838Z</updated>
  <id>https://iceyxiner.github.io/</id>
  
  <author>
    <name>ICEY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构-单链表</title>
    <link href="https://iceyxiner.github.io/2019/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <id>https://iceyxiner.github.io/2019/05/23/数据结构-单链表/</id>
    <published>2019-05-23T06:00:00.000Z</published>
    <updated>2019-05-24T03:19:27.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-单链表"><a href="#数据结构-单链表" class="headerlink" title="数据结构-单链表"></a>数据结构-单链表</h1><h2 id="1、单链表简介"><a href="#1、单链表简介" class="headerlink" title="1、单链表简介"></a>1、单链表简介</h2><h3 id="1-1、概念介绍"><a href="#1-1、概念介绍" class="headerlink" title="1.1、概念介绍"></a>1.1、概念介绍</h3><blockquote><p>&emsp;&emsp;链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象) + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。<br>以“结点的序列”表示线性表称作线性链表（全称为: 以链接方式存储的线性表），链表是链式存取的结构。</p></blockquote><a id="more"></a><h3 id="1-2、链接存储方法的具体存储表示"><a href="#1-2、链接存储方法的具体存储表示" class="headerlink" title="1.2、链接存储方法的具体存储表示"></a>1.2、链接存储方法的具体存储表示</h3><blockquote><p>① 用一组任意的存储单元来存放线性表的结点（这组存储单元既可以是连续的，也可以是不连续的）</p><p><img src="/2019/05/23/数据结构-单链表/带有头结点的单链表.png" alt></p><p>② 链表中结点的逻辑次序和物理次序不一定相同。为了能正确表示结点间的逻辑关系，在存储每个结点值的同时，还必须存储指示其后继结点的地址信息。</p><p><img src="/2019/05/23/数据结构-单链表/链表结构-指针域结构.png" alt></p></blockquote><!-- more --><h2 id="2、单链表的储存结构"><a href="#2、单链表的储存结构" class="headerlink" title="2、单链表的储存结构"></a>2、单链表的储存结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node, *LinkedList;</span><br></pre></td></tr></table></figure><h2 id="3、单链表的初始化"><a href="#3、单链表的初始化" class="headerlink" title="3、单链表的初始化"></a>3、单链表的初始化</h2><h3 id="3-1、头插法"><a href="#3-1、头插法" class="headerlink" title="3.1、头插法"></a>3.1、头插法</h3><p><img src="/2019/05/23/数据结构-单链表/单链表-头插法.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随即产生n个元素的值,建立带表头结点的单链线性表L</span></span><br><span class="line"><span class="comment"> * 头插法</span></span><br><span class="line"><span class="comment"> * @param L 单链表头结点地址</span></span><br><span class="line"><span class="comment"> * @param n 生成链表长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListHead</span><span class="params">(LinkedList *L, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    LinkedList newNode;</span><br><span class="line">    srand(<span class="keyword">time_t</span>(<span class="number">0</span>));        <span class="comment">// 初始化随机数种子</span></span><br><span class="line">    <span class="comment">// 初始化一个空链表L</span></span><br><span class="line">    *L = (LinkedList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    (*L)-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 循环生成链表结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 为新链表结点分配一个地址</span></span><br><span class="line">        newNode = (LinkedList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="comment">// 初始化新链表结点中的域,随机生成100以内的数字</span></span><br><span class="line">        newNode-&gt;data = rand() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 将新链表结点插入到头结点与前一新结点之间</span></span><br><span class="line">        newNode-&gt;next = (*L)-&gt;next;</span><br><span class="line">        (*L)-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、尾插法"><a href="#3-2、尾插法" class="headerlink" title="3.2、尾插法"></a>3.2、尾插法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随即产生n个元素的值,建立带表头结点的单链线性表L</span></span><br><span class="line"><span class="comment"> * 尾插法</span></span><br><span class="line"><span class="comment"> * @param L 单链表头结点地址</span></span><br><span class="line"><span class="comment"> * @param n 生成链表长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListTail</span><span class="params">(LinkedList *L, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    LinkedList tailNode, newNode;</span><br><span class="line">    srand(<span class="keyword">time_t</span>(<span class="number">0</span>)); <span class="comment">// 初始化随机数种子</span></span><br><span class="line">    <span class="comment">// 初始化一个空链表L</span></span><br><span class="line">    *L = (LinkedList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="comment">// 指向尾部的结点</span></span><br><span class="line">    tailNode = *L;</span><br><span class="line">    <span class="comment">// 循环生成链表结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 为新链表结点分配一个地址</span></span><br><span class="line">        newNode = (LinkedList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        <span class="comment">// 初始化新链表结点中的域,随机生成100以内的数字</span></span><br><span class="line">        newNode-&gt;data = rand() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 将链表尾部终端结点的指针指向新结点</span></span><br><span class="line">        tailNode-&gt;next = newNode;</span><br><span class="line">        <span class="comment">// 将当前新结点定义为链表尾部终端结点</span></span><br><span class="line">        tailNode = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前链表尾部为NULL,链表结束</span></span><br><span class="line">    tailNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、获取链表内指定位置数据元素"><a href="#4、获取链表内指定位置数据元素" class="headerlink" title="4、获取链表内指定位置数据元素"></a>4、获取链表内指定位置数据元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取单链表中的第i个元素</span></span><br><span class="line"><span class="comment"> * 最坏时间复杂度O(n)</span></span><br><span class="line"><span class="comment"> * @param L 单链表头结点地址</span></span><br><span class="line"><span class="comment"> * @param i 第i个元素</span></span><br><span class="line"><span class="comment"> * @param e 第i个元素的数据域</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Status <span class="title">GetElement</span><span class="params">(LinkedList L, <span class="keyword">int</span> i, ElemType *e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历计数器设置为1</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取第一个元素节点</span></span><br><span class="line">    LinkedList p = L-&gt;next;</span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断条件</span></span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、在链表内指定位置插入数据元素"><a href="#5、在链表内指定位置插入数据元素" class="headerlink" title="5、在链表内指定位置插入数据元素"></a>5、在链表内指定位置插入数据元素</h2><p><img src="/2019/05/23/数据结构-单链表/单链表插入.png" alt></p><p><img src="/2019/05/23/数据结构-单链表/单链表插入表头、表尾.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在L中的第i个位置前插入新数据元素e,L的长度加1</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(1)</span></span><br><span class="line"><span class="comment"> * @param L 单链表头结点地址</span></span><br><span class="line"><span class="comment"> * @param i 第i个位置</span></span><br><span class="line"><span class="comment"> * @param e 新数据元素</span></span><br><span class="line"><span class="comment"> * @return Status</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Status <span class="title">Insert</span><span class="params">(LinkedList *L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历计数器设置为1</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取头结点</span></span><br><span class="line">    LinkedList p = *L;</span><br><span class="line">    <span class="comment">// 遍历查找第i个元素</span></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第i个元素不存在</span></span><br><span class="line">    <span class="keyword">if</span> (!p &amp;&amp; j &gt; i)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="comment">// 创建新结点并为之分配内存</span></span><br><span class="line">    LinkedList s = (LinkedList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="comment">// 为新结点初始化数据</span></span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    <span class="comment">// 将新结点的后继结点设置为插入位置后的结点</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="comment">// 前驱结点设置为插入位置前的结点</span></span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、在链表内删除指定位置的数据元素"><a href="#5、在链表内删除指定位置的数据元素" class="headerlink" title="5、在链表内删除指定位置的数据元素"></a>5、在链表内删除指定位置的数据元素</h2><p><img src="/2019/05/23/数据结构-单链表/单链表删除.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除L中的第i个数据元素,并用e返回其值,L的长度减1</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(1)</span></span><br><span class="line"><span class="comment"> * @param L 单链表头结点地址</span></span><br><span class="line"><span class="comment"> * @param i 第i个位置</span></span><br><span class="line"><span class="comment"> * @param e 被删除的数据元素</span></span><br><span class="line"><span class="comment"> * @return Status</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(LinkedList *L, <span class="keyword">int</span> i, ElemType *e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历计数器设置为1</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取头节点</span></span><br><span class="line">    LinkedList p = *L, q;</span><br><span class="line">    <span class="comment">// 遍历查找第i个元素</span></span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第i个元素不存在</span></span><br><span class="line">    <span class="keyword">if</span> (!(p-&gt;next) || j &gt; i)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="comment">// 将q指针指向为第i个元素,此时p指针指向第i-1个元素,q指针指向第i个元素</span></span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    <span class="comment">// 将p(第i-1个元素)的后继元素定义为q(第i个元素)的后继元素</span></span><br><span class="line">    <span class="comment">// 即空开第i个元素,将第i-1个元素和第i个元素相连</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="comment">// e返回删除元素的数据域</span></span><br><span class="line">    *e = q-&gt;data;</span><br><span class="line">    <span class="comment">// free函数回收q所占用的内存</span></span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构-单链表&quot;&gt;&lt;a href=&quot;#数据结构-单链表&quot; class=&quot;headerlink&quot; title=&quot;数据结构-单链表&quot;&gt;&lt;/a&gt;数据结构-单链表&lt;/h1&gt;&lt;h2 id=&quot;1、单链表简介&quot;&gt;&lt;a href=&quot;#1、单链表简介&quot; class=&quot;headerlink&quot; title=&quot;1、单链表简介&quot;&gt;&lt;/a&gt;1、单链表简介&lt;/h2&gt;&lt;h3 id=&quot;1-1、概念介绍&quot;&gt;&lt;a href=&quot;#1-1、概念介绍&quot; class=&quot;headerlink&quot; title=&quot;1.1、概念介绍&quot;&gt;&lt;/a&gt;1.1、概念介绍&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象) + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。&lt;br&gt;以“结点的序列”表示线性表称作线性链表（全称为: 以链接方式存储的线性表），链表是链式存取的结构。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://iceyxiner.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://iceyxiner.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线性表" scheme="https://iceyxiner.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
      <category term="链式储存结构" scheme="https://iceyxiner.github.io/tags/%E9%93%BE%E5%BC%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    
      <category term="单链表" scheme="https://iceyxiner.github.io/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-静态链表</title>
    <link href="https://iceyxiner.github.io/2019/05/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"/>
    <id>https://iceyxiner.github.io/2019/05/20/数据结构-静态链表/</id>
    <published>2019-05-20T06:00:00.000Z</published>
    <updated>2019-05-23T08:13:05.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-静态链表"><a href="#数据结构-静态链表" class="headerlink" title="数据结构-静态链表"></a>数据结构-静态链表</h1><h2 id="1、静态链表的简介"><a href="#1、静态链表的简介" class="headerlink" title="1、静态链表的简介"></a>1、静态链表的简介</h2><blockquote><p>&emsp;&emsp;在一些早期的编程语言，由于没有指针的概念，有人想到了用数组来实现单链表的方法，改进了顺序存储结构中插入和删除操作需要移动大量元素的缺点。实现逻辑简单来说，是让数组的元素由两个数据域组成，data和cur。数组的每个下标都对应一个数据存放域data和一个游标cur。游标cur相当于单链表中的next指针，存放该元素的后继在数组中的下标，从而用游标来记录每个元素的顺序。所以，用数组描述的链表叫做静态链表。</p></blockquote><a id="more"></a><h2 id="2、静态链表的储存结构"><a href="#2、静态链表的储存结构" class="headerlink" title="2、静态链表的储存结构"></a>2、静态链表的储存结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> cur;</span><br><span class="line">&#125; StaticLinkedList[MAXSIZE];</span><br></pre></td></tr></table></figure><h2 id="3、静态链表的初始化"><a href="#3、静态链表的初始化" class="headerlink" title="3、静态链表的初始化"></a>3、静态链表的初始化</h2><p><img src="/2019/05/20/数据结构-静态链表/static-init.png" alt="静态链表结构"></p><blockquote><p>当静态链表为空时，头结点指向的备用链表的第一个元素(也就是空结点链表)下标为1，尾结点指向的第一个插入元素下标为0。</p></blockquote><p><img src="/2019/05/20/数据结构-静态链表/static-init-finish.png" alt="静态链表初始化"></p><blockquote><p>当静态链表装填了6个数据时，头结点指向的备用链表的第一个元素(也就是空结点链表)下标为7，尾结点指向的第一个插入元素下标为1。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化静态链表</span></span><br><span class="line"><span class="comment">* 例:</span></span><br><span class="line"><span class="comment">* 下标   0    1   2   3   4   5   6   7   8   9</span></span><br><span class="line"><span class="comment">* 游标   1    2   3   4   5   6   7   8   9   0</span></span><br><span class="line"><span class="comment">* 数据   头   -   -   -   -   -   -   -   -   尾</span></span><br><span class="line"><span class="comment">* 其中 头结点、尾结点、空结点数据为空</span></span><br><span class="line"><span class="comment">* 头结点的游标cur存放备用链表第一个结点的下标</span></span><br><span class="line"><span class="comment">* 尾结点的游标cur存放第一个插入元素的下标</span></span><br><span class="line"><span class="comment">* @param space</span></span><br><span class="line"><span class="comment">* @return Status</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(StaticLinkedList space)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        space[i].cur = i + <span class="number">1</span>;</span><br><span class="line">        space[i].data = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    space[MAXSIZE - <span class="number">1</span>].cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、静态链表的插入"><a href="#4、静态链表的插入" class="headerlink" title="4、静态链表的插入"></a>4、静态链表的插入</h2><p><img src="/2019/05/20/数据结构-静态链表/static-insert.png" alt="静态链表插入"></p><blockquote><p>当一个新元素被填装到静态链表里，通过插入位置前置元素游标和新元素游标的改变，使得该元素被连接到静态链表的任意位置中。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 取得StaticLinkedList的长度</span></span><br><span class="line"><span class="comment">* @param L</span></span><br><span class="line"><span class="comment">* @return int Length</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(StaticLinkedList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从尾结点获取第一个有元素的结点</span></span><br><span class="line">    <span class="keyword">int</span> i = L[MAXSIZE - <span class="number">1</span>].cur;</span><br><span class="line">    <span class="comment">// 遍历计数</span></span><br><span class="line">    <span class="keyword">while</span> (i) &#123;</span><br><span class="line">        i = L[i].cur;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 若备用空间链表非空,则返回分配的结点下标,否则返回0</span></span><br><span class="line"><span class="comment">* 例:</span></span><br><span class="line"><span class="comment">* 下标   0    1   2   3   4   5   6   7   8   9</span></span><br><span class="line"><span class="comment">* 游标   4    2   3   4   0   6   7   8   9   1</span></span><br><span class="line"><span class="comment">* 数据   头   +   +   +   +   -   -   -   -   尾</span></span><br><span class="line"><span class="comment">* @param space</span></span><br><span class="line"><span class="comment">* @return 分配的链表下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc_SLL</span><span class="params">(StaticLinkedList space)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = space[<span class="number">0</span>].cur; <span class="comment">// 当前数组第一个元素cur存的值,即链表总长的下个元素的下标</span></span><br><span class="line">    <span class="keyword">if</span> (space[<span class="number">0</span>].cur)     <span class="comment">// 判断是否为链表尾</span></span><br><span class="line">        space[<span class="number">0</span>].cur = space[i].cur; <span class="comment">// 将这个空间分量分配出去,并取下个分量备用</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在L中第i个元素之前插入新的数据元素e</span></span><br><span class="line"><span class="comment">* 例(插入前):</span></span><br><span class="line"><span class="comment">* 下标   0    1   2   3   4   5   6   7   8   9</span></span><br><span class="line"><span class="comment">* 游标   4    2   3   4   0   6   7   8   9   1</span></span><br><span class="line"><span class="comment">* 数据   头   +   +   +   +   -   -   -   -   尾</span></span><br><span class="line"><span class="comment">* 例(插入后, i=3):</span></span><br><span class="line"><span class="comment">*                |----------&gt;|(2-&gt;5)</span></span><br><span class="line"><span class="comment">* 下标   0    1   2   3   4   5   6   7   8   9</span></span><br><span class="line"><span class="comment">* 游标   4    2   5   4   0   6   7   8   9   1</span></span><br><span class="line"><span class="comment">* 数据   头   +   +   +   +   *   -   -   -   尾</span></span><br><span class="line"><span class="comment">*                    |&lt;------|(5-&gt;3)</span></span><br><span class="line"><span class="comment">* @param L</span></span><br><span class="line"><span class="comment">* @param i 在下标为i的元素前,插入一个新的元素</span></span><br><span class="line"><span class="comment">* @param e 新元素</span></span><br><span class="line"><span class="comment">* @return Status</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">Insert</span><span class="params">(StaticLinkedList L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; Length(L) + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = Malloc_SLL(L);</span><br><span class="line">    <span class="comment">//尾结点下标</span></span><br><span class="line">    <span class="keyword">int</span> k = MAXSIZE - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (j) &#123;</span><br><span class="line">        <span class="comment">// 为新元素赋值</span></span><br><span class="line">        L[j].data = e;</span><br><span class="line">        <span class="comment">// 找到插入元素的前一个元素的游标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= i - <span class="number">1</span>; l++)</span><br><span class="line">            k = L[k].cur;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 简单的来说</span></span><br><span class="line"><span class="comment">        * ① | ② | ③</span></span><br><span class="line"><span class="comment">        * ① 是插入元素前的元素,下标为k,下一元素下标为L[k].cur</span></span><br><span class="line"><span class="comment">        * ② 是新插入元素,下标为j,下一元素下标为L[j].cur</span></span><br><span class="line"><span class="comment">        * ③ 是插入元素后的元素,即插入前在①的下一位,插入后在②的下一位,下标为L[k].cur</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        L[j].cur = L[k].cur; <span class="comment">// 将②的游标定为③</span></span><br><span class="line">        L[k].cur = j; <span class="comment">// 将①的游标定为</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、静态链表的删除"><a href="#5、静态链表的删除" class="headerlink" title="5、静态链表的删除"></a>5、静态链表的删除</h2><p><img src="/2019/05/20/数据结构-静态链表/static-delete.png" alt="静态链表删除"></p><blockquote><p>当一个元素从静态链表删除时，通过删除位置前置元素游标和删除元素游标的改变，使得该元素被从静态链表中解除，并将该删除元素使用头插法连接到头结点索引的备用链表中。该元素会在分配空间向量时优先被使用。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 取得StaticLinkedList的长度</span></span><br><span class="line"><span class="comment">* @param L</span></span><br><span class="line"><span class="comment">* @return int Length</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(StaticLinkedList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从尾结点获取第一个有元素的结点</span></span><br><span class="line">    <span class="keyword">int</span> i = L[MAXSIZE - <span class="number">1</span>].cur;</span><br><span class="line">    <span class="comment">// 遍历计数</span></span><br><span class="line">    <span class="keyword">while</span> (i) &#123;</span><br><span class="line">        i = L[i].cur;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将下标为k的空闲结点回收到到备用链表</span></span><br><span class="line"><span class="comment">* 也就是将删除数据后的空结点直接排在头结点后,并将之前的第一个空结点排在它之后</span></span><br><span class="line"><span class="comment">* @param space</span></span><br><span class="line"><span class="comment">* @param k 删除下标为k的元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free_SSL</span><span class="params">(StaticLinkedList space, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    space[k].cur = space[<span class="number">0</span>].cur;</span><br><span class="line">    space[<span class="number">0</span>].cur = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除下标为i的结点</span></span><br><span class="line"><span class="comment">* 在L中第i个元素之前插入新的数据元素e</span></span><br><span class="line"><span class="comment">* 例(删除前):</span></span><br><span class="line"><span class="comment">*       |-------------------------------&gt;|(头结点指向第一个空结点)</span></span><br><span class="line"><span class="comment">* 下标   0    1   2   3   4   5   6   7   8   9</span></span><br><span class="line"><span class="comment">* 游标   8    2   7   4   0   6   0   3   9   1</span></span><br><span class="line"><span class="comment">* 数据   头   +   +   +   +   +   +   *   -   尾</span></span><br><span class="line"><span class="comment">* 例(删除后, i=1):</span></span><br><span class="line"><span class="comment">*       |---&gt;|(头结点先指向删除后的备用结点)</span></span><br><span class="line"><span class="comment">*                |&lt;--------------------------|(尾结点指向第一个非空的结点)</span></span><br><span class="line"><span class="comment">* 下标   0    1   2   3   4   5   6   7   8   9</span></span><br><span class="line"><span class="comment">* 游标   1    8   7   4   5   6   0   3   9   2</span></span><br><span class="line"><span class="comment">* 数据   头   -   +   +   +   +   +   *   -   尾</span></span><br><span class="line"><span class="comment">*            |--------------------------&gt;|(头结点的后继元素再指向删除前的第一个空结点)</span></span><br><span class="line"><span class="comment">* @param L</span></span><br><span class="line"><span class="comment">* @param i 删除第i个结点</span></span><br><span class="line"><span class="comment">* @return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(StaticLinkedList L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="comment">// 判断是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; Length(L))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="comment">// 尾结点下标</span></span><br><span class="line">    <span class="keyword">int</span> k = MAXSIZE - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//k = 第i-1个元素的下标</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)</span><br><span class="line">        k = L[k].cur;</span><br><span class="line">    <span class="comment">// j = 第i个元素的下标</span></span><br><span class="line">    <span class="comment">// 解除第i个元素前后索引</span></span><br><span class="line">    j = L[k].cur;</span><br><span class="line">    L[k].cur = L[j].cur;</span><br><span class="line">    <span class="comment">// 回收空结点</span></span><br><span class="line">    L[j].data = - <span class="number">1</span>;</span><br><span class="line">    Free_SSL(L, j);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、静态链表优缺点"><a href="#6、静态链表优缺点" class="headerlink" title="6、静态链表优缺点"></a>6、静态链表优缺点</h2><blockquote><p>优点:&emsp;在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了顺序存储结构中插入和删除操作需要移动大量元素的缺点。</p><p>缺点:&emsp;没有解决连续存储分配带来的表长难以确定的问题；失去了顺序存储结构随机存取的特性。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构-静态链表&quot;&gt;&lt;a href=&quot;#数据结构-静态链表&quot; class=&quot;headerlink&quot; title=&quot;数据结构-静态链表&quot;&gt;&lt;/a&gt;数据结构-静态链表&lt;/h1&gt;&lt;h2 id=&quot;1、静态链表的简介&quot;&gt;&lt;a href=&quot;#1、静态链表的简介&quot; class=&quot;headerlink&quot; title=&quot;1、静态链表的简介&quot;&gt;&lt;/a&gt;1、静态链表的简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;在一些早期的编程语言，由于没有指针的概念，有人想到了用数组来实现单链表的方法，改进了顺序存储结构中插入和删除操作需要移动大量元素的缺点。实现逻辑简单来说，是让数组的元素由两个数据域组成，data和cur。数组的每个下标都对应一个数据存放域data和一个游标cur。游标cur相当于单链表中的next指针，存放该元素的后继在数组中的下标，从而用游标来记录每个元素的顺序。所以，用数组描述的链表叫做静态链表。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://iceyxiner.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://iceyxiner.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线性表" scheme="https://iceyxiner.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
      <category term="链式储存结构" scheme="https://iceyxiner.github.io/tags/%E9%93%BE%E5%BC%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    
      <category term="静态链表" scheme="https://iceyxiner.github.io/tags/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-线性表</title>
    <link href="https://iceyxiner.github.io/2019/05/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://iceyxiner.github.io/2019/05/18/数据结构-线性表/</id>
    <published>2019-05-18T06:00:00.000Z</published>
    <updated>2019-05-23T03:00:56.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-线性表"><a href="#数据结构-线性表" class="headerlink" title="数据结构-线性表"></a>数据结构-线性表</h1><h2 id="1、线性表的定义"><a href="#1、线性表的定义" class="headerlink" title="1、线性表的定义"></a>1、线性表的定义</h2><blockquote><p>零个或多个数据元素的优先序列。若将线性表记为(a<sub>1</sub>, … a<sub>i-1</sub>, a<sub>i</sub>, a<sub>i+1</sub>, … a<sub>n</sub>)，则表中 a<sub>i-1</sub> 领先于 a<sub>i</sub>, a<sub>i</sub> 领先于 a<sub>i+1</sub>，称 a<sub>i-1</sub> 是 a<sub>i</sub> 的直接前驱元素，a<sub>i+1</sub> 是 a<sub>i</sub> 的直接后继元素。当 i=1，2，3，…，n时，a<sub>i</sub>有且仅有一个直接前驱。所以线性表元素的个数n（n&gt;0）定义为线性表长度，当 n=0 时，称为空表。</p></blockquote><a id="more"></a><h2 id="2、线性表的抽象数据类型"><a href="#2、线性表的抽象数据类型" class="headerlink" title="2、线性表的抽象数据类型"></a>2、线性表的抽象数据类型</h2><blockquote><table><thead><tr><th>ADT</th></tr></thead><tbody><tr><td>线性表(List)</td><td></td></tr></tbody></table><table><thead><tr><th>Data</th></tr></thead><tbody><tr><td>线性表的数据对象集合为{a<sub>1</sub>, .. a<sub>n</sub>}。每个元素的类型均为DataType。其中，除第一个元素a<sub>1</sub>外，每一个有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系时一对一的关系。</td><td></td></tr></tbody></table><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>InitList(*L)</td><td>初始化操作，建立一个空的线性表L </td></tr><tr><td>IsEmpty(L)</td><td>若线性表为空，返回TRUE，否则返回FALSE </td></tr><tr><td>Length(L)</td><td>返回线性表L的元素个数 </td></tr><tr><td>Clear(*L)</td><td>将线性表清空 </td></tr><tr><td>GetElement(L, i, *e)</td><td>将线性表L中的第i个位置元素值返回给e </td></tr><tr><td>LocateElement(L, e)</td><td>在线性表L中寻找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败。 </td></tr><tr><td>Insert(*L, i, e)</td><td>在线性表L中第i个位置插入新元素e </td></tr><tr><td>Delete(<em>L, i, </em>e)</td><td>删除线性表L中 </td></tr></tbody></table></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构-线性表&quot;&gt;&lt;a href=&quot;#数据结构-线性表&quot; class=&quot;headerlink&quot; title=&quot;数据结构-线性表&quot;&gt;&lt;/a&gt;数据结构-线性表&lt;/h1&gt;&lt;h2 id=&quot;1、线性表的定义&quot;&gt;&lt;a href=&quot;#1、线性表的定义&quot; class=&quot;headerlink&quot; title=&quot;1、线性表的定义&quot;&gt;&lt;/a&gt;1、线性表的定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;零个或多个数据元素的优先序列。若将线性表记为(a&lt;sub&gt;1&lt;/sub&gt;, … a&lt;sub&gt;i-1&lt;/sub&gt;, a&lt;sub&gt;i&lt;/sub&gt;, a&lt;sub&gt;i+1&lt;/sub&gt;, … a&lt;sub&gt;n&lt;/sub&gt;)，则表中 a&lt;sub&gt;i-1&lt;/sub&gt; 领先于 a&lt;sub&gt;i&lt;/sub&gt;, a&lt;sub&gt;i&lt;/sub&gt; 领先于 a&lt;sub&gt;i+1&lt;/sub&gt;，称 a&lt;sub&gt;i-1&lt;/sub&gt; 是 a&lt;sub&gt;i&lt;/sub&gt; 的直接前驱元素，a&lt;sub&gt;i+1&lt;/sub&gt; 是 a&lt;sub&gt;i&lt;/sub&gt; 的直接后继元素。当 i=1，2，3，…，n时，a&lt;sub&gt;i&lt;/sub&gt;有且仅有一个直接前驱。所以线性表元素的个数n（n&amp;gt;0）定义为线性表长度，当 n=0 时，称为空表。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://iceyxiner.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://iceyxiner.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线性表" scheme="https://iceyxiner.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
</feed>
