<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构-循环链表]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据结构-循环链表1、循环链表简介 &emsp;&emsp;循环链表是另一种形式的链式存贮结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。 2、循环链表的存储结构123456typedef int ElemType;typedef struct Node &#123; int data; struct Node *next;&#125; Node, *CircularLinkedList; 3、循环链表的初始化3.1、头插法123456789101112131415161718192021222324/** * 随即产生n个元素的值,建立循环链表L * 头插法 -- 即倒序填装 * @param L 单链表头结点地址 * @param n 生成链表长度 */void CreateListHead(CircularLinkedList *L, int n) &#123; CircularLinkedList newNode; srand(time_t(0)); // 初始化随机数种子 // 初始化循环链表的第一个结点 *L = (CircularLinkedList) malloc(sizeof(Node)); (*L)-&gt;data = rand() % 100 + 1; (*L)-&gt;next = *L; // 循环生成链表结点 for (int i = 1; i &lt; n; i++) &#123; // 为新链表结点分配一个地址 newNode = (CircularLinkedList) malloc(sizeof(Node)); // 初始化新链表结点中的域,随机生成100以内的数字 newNode-&gt;data = rand() % 100 + 1; // 将新链表结点插入到头结点与前一新结点之间 newNode-&gt;next = (*L)-&gt;next; (*L)-&gt;next = newNode; &#125;&#125; 3.2、尾插法12345678910111213141516171819202122232425262728/** * 随即产生n个元素的值,建立循环链表L * 尾插法 -- 即顺序填装 * @param L 循环链表头结点地址 * @param n 生成链表长度 */void CreateListTail(CircularLinkedList *L, int n) &#123; CircularLinkedList tailNode, newNode; srand(time_t(0)); // 初始化随机数种子 // 初始化循环链表的第一个结点 *L = (CircularLinkedList) malloc(sizeof(Node)); (*L)-&gt;data = rand() % 100 + 1; // 指向尾部的结点 tailNode = *L; // 循环生成链表结点 for (int i = 1; i &lt; n; i++) &#123; // 为新链表结点分配一个地址 newNode = (CircularLinkedList) malloc(sizeof(Node)); // 初始化新链表结点中的域,随机生成100以内的数字 newNode-&gt;data = rand() % 100 + 1; // 将链表尾部终端结点的指针指向新结点 tailNode-&gt;next = newNode; // 将当前新结点定义为链表尾部终端结点 tailNode = newNode; &#125; // 将链表尾部连接到头部 tailNode-&gt;next = *L;&#125; 4、在链表内指定位置插入数据元素12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 在L中的第i个位置前插入新数据元素e,L的长度加1 * 时间复杂度O(1) * @param L 循环链表头结点地址 * @param i 第i个位置 * @param e 新数据元素 * @return Status */Status Insert(CircularLinkedList *L, int i, ElemType e) &#123; CircularLinkedList p = *L, s; // 对于循环链表,因为头结点相对特殊,需要单独处理 // 即在头结点前插入元素后,将表头结点地址更改为新插入结点地址 if (i == 1) &#123; // 将p指针指向链表最后一个元素 for (; p-&gt;next != *L; p = p-&gt;next); // 创建新结点并为之分配内存 s = (CircularLinkedList) malloc(sizeof(Node)); // 为新结点初始化数据 s-&gt;data = e; // 将新结点的后继结点设置为插入位置后的结点(即之前的头结点) s-&gt;next = p-&gt;next; // 前驱结点设置为插入位置前的结点(即尾结点) p-&gt;next = s; //将表头结点地址更改为新插入结点地址 *L = s; &#125; else &#123; int j = 1; // 遍历查找第i个元素 for (;p-&gt;next != *L &amp;&amp; j &lt; i - 1;p = p-&gt;next, ++j); // 第i个元素不存在 if (p == *L &amp;&amp; j &gt; i) return ERROR; // 创建新结点并为之分配内存 s = (CircularLinkedList) malloc(sizeof(Node)); // 为新结点初始化数据 s-&gt;data = e; // 将新结点的后继结点设置为插入位置后的结点 s-&gt;next = p-&gt;next; // 前驱结点设置为插入位置前的结点 p-&gt;next = s; &#125; return OK;&#125; 5、在链表内删除指定位置的数据元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 删除L中的第i个数据元素,并用e返回其值,L的长度减1 * 时间复杂度O(1) * @param L 循环链表头结点地址 * @param i 第i个位置 * @param e 被删除的数据元素 * @return Status */Status Delete(CircularLinkedList *L, int i, ElemType *e) &#123; CircularLinkedList p = *L, q; if (i == 1)&#123; // q指针指向第二个结点 q = p-&gt;next; // 遍历到链表尾 for (; p-&gt;next != *L; p = p-&gt;next); // 将p(尾结点)的后继元素定义为q(第1个元素)的后继元素 // 即空开第1个元素,将第i个元素和第2个元素相连 p-&gt;next = q; // 重新将p指针指向被孤立的元素(即马上被删掉的头结点) p = *L; // e返回删除元素的数据域 *e = p-&gt;data; // 将头结点移动到第二个元素结点 *L = q; // free函数回收q所占用的内存 free(p); &#125; else &#123; // 遍历计数器设置为2(从第二个开始) int j = 2; // 获取头节点 CircularLinkedList p = *L, q; // 遍历查找第i个元素 for (;p-&gt;next != *L &amp;&amp; j &lt; i;p = p-&gt;next, ++j); // 第i个元素不存在 if (i &gt;= j) return ERROR; // 将q指针指向为第i个元素,此时p指针指向第i-1个元素,q指针指向第i个元素 q = p-&gt;next; // 将p(第i-1个元素)的后继元素定义为q(第i个元素)的后继元素 // 即空开第i个元素,将第i-1个元素和第i个元素相连 p-&gt;next = q-&gt;next; // e返回删除元素的数据域 *e = q-&gt;data; // free函数回收q所占用的内存 free(q); &#125; return OK;&#125; 6、打印链表中内容12345678void PrintList(CircularLinkedList L) &#123; CircularLinkedList target = L; do &#123; std::cout &lt;&lt; target-&gt;data &lt;&lt; " "; target = target-&gt;next; &#125; while ((target != L)); // 防止无限循环下去 std::cout &lt;&lt; std::endl;&#125; 参考资料 大话数据结构&emsp;2019-05-26]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
        <tag>链式存储结构</tag>
        <tag>循环链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-单链表]]></title>
    <url>%2F2019%2F05%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据结构-单链表1、单链表简介1.1、概念介绍 &emsp;&emsp;链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象) + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。以“结点的序列”表示线性表称作线性链表（属于链式存储结构的线性表）。 1.2、链接存储方法的具体存储表示 ① 用一组任意的存储单元来存放线性表的结点（这组存储单元既可以是连续的，也可以是不连续的） ② 链表中结点的逻辑次序和物理次序不一定相同。为了能正确表示结点间的逻辑关系，在存储每个结点值的同时，还必须存储指示其后继结点的地址信息。 2、单链表的存储结构123456typedef int ElemType;typedef struct Node &#123; ElemType data; struct Node *next;&#125; Node, *LinkedList; 3、单链表的初始化3.1、头插法 123456789101112131415161718192021222324/** * 随即产生n个元素的值,建立带表头结点的单链线性表L * 头插法 * @param L 单链表头结点地址 * @param n 生成链表长度 */void CreateListHead(LinkedList *L, int n) &#123; LinkedList newNode; srand(time_t(0)); // 初始化随机数种子 // 初始化一个空链表L *L = (LinkedList) malloc(sizeof(Node)); (*L)-&gt;next = nullptr; // 循环生成链表结点 for (int i = 0; i &lt; n; i++) &#123; // 为新链表结点分配一个地址 newNode = (LinkedList) malloc(sizeof(Node)); // 初始化新链表结点中的域,随机生成100以内的数字 newNode-&gt;data = rand() % 100 + 1; // 将新链表结点插入到头结点与前一新结点之间 newNode-&gt;next = (*L)-&gt;next; (*L)-&gt;next = newNode; &#125;&#125; 3.2、尾插法123456789101112131415161718192021222324252627/** * 随即产生n个元素的值,建立带表头结点的单链线性表L * 尾插法 * @param L 单链表头结点地址 * @param n 生成链表长度 */void CreateListTail(LinkedList *L, int n) &#123; LinkedList tailNode, newNode; srand(time_t(0)); // 初始化随机数种子 // 初始化一个空链表L *L = (LinkedList) malloc(sizeof(Node)); // 指向尾部的结点 tailNode = *L; // 循环生成链表结点 for (int i = 0; i &lt; n; i++) &#123; // 为新链表结点分配一个地址 newNode = (LinkedList) malloc(sizeof(Node)); // 初始化新链表结点中的域,随机生成100以内的数字 newNode-&gt;data = rand() % 100 + 1; // 将链表尾部终端结点的指针指向新结点 tailNode-&gt;next = newNode; // 将当前新结点定义为链表尾部终端结点 tailNode = newNode; &#125; // 当前链表尾部为NULL,链表结束 tailNode-&gt;next = nullptr;&#125; 4、获取链表内指定位置数据元素123456789101112131415161718192021222324/** * 获取单链表中的第i个元素 * 最坏时间复杂度O(n) * @param L 单链表头结点地址 * @param i 第i个元素 * @param e 第i个元素的数据域 * @return */Status GetElement(LinkedList L, int i, ElemType *e) &#123; // 遍历计数器设置为1 int j = 1; // 获取第一个元素节点 LinkedList p = L-&gt;next; // 遍历链表 while (p &amp;&amp; j &lt; i) &#123; p = p-&gt;next; j++; &#125; // 判断条件 if (!p || j &gt; i) return ERROR; *e = p-&gt;data; return OK;&#125; 5、在链表内指定位置插入数据元素 12345678910111213141516171819202122232425262728293031/** * 在L中的第i个位置前插入新数据元素e,L的长度加1 * 时间复杂度O(1) * @param L 单链表头结点地址 * @param i 第i个位置 * @param e 新数据元素 * @return Status */Status Insert(LinkedList *L, int i, ElemType e) &#123; // 遍历计数器设置为1 int j = 1; // 获取头结点 LinkedList p = *L; // 遍历查找第i个元素 while (p &amp;&amp; j &lt; i) &#123; p = p-&gt;next; ++j; &#125; // 第i个元素不存在 if (!p &amp;&amp; j &gt; i) return ERROR; // 创建新结点并为之分配内存 LinkedList s = (LinkedList) malloc(sizeof(Node)); // 为新结点初始化数据 s-&gt;data = e; // 将新结点的后继结点设置为插入位置后的结点 s-&gt;next = p-&gt;next; // 前驱结点设置为插入位置前的结点 p-&gt;next = s; return OK;&#125; 6、在链表内删除指定位置的数据元素 1234567891011121314151617181920212223242526272829303132/** * 删除L中的第i个数据元素,并用e返回其值,L的长度减1 * 时间复杂度O(1) * @param L 单链表头结点地址 * @param i 第i个位置 * @param e 被删除的数据元素 * @return Status */Status Delete(LinkedList *L, int i, ElemType *e) &#123; // 遍历计数器设置为1 int j = 1; // 获取头节点 LinkedList p = *L, q; // 遍历查找第i个元素 while (p-&gt;next &amp;&amp; j &lt; i) &#123; p = p-&gt;next; ++j; &#125; // 第i个元素不存在 if (!(p-&gt;next) || j &gt; i) return ERROR; // 将q指针指向为第i个元素,此时p指针指向第i-1个元素,q指针指向第i个元素 q = p-&gt;next; // 将p(第i-1个元素)的后继元素定义为q(第i个元素)的后继元素 // 即空开第i个元素,将第i-1个元素和第i个元素相连 p-&gt;next = q-&gt;next; // e返回删除元素的数据域 *e = q-&gt;data; // free函数回收q所占用的内存 free(q); return OK;&#125; 7、清空链表123456789101112131415161718192021/** * 将L重置为空表 * @param L 单链表头结点地址 * @return Status */Status Clear(LinkedList *L) &#123; LinkedList p, q; // p指针指向第一个结点 p = (*L)-&gt;next; // 循环直至表尾 while (p) &#123; // q指针记录p的下一个结点 // 如果无此变量,释放p后,无法找到下个元素 q = p-&gt;next; free(p); p = q; &#125; // 头结点指针域为NULL (*L)-&gt;next = nullptr; return OK;&#125; 8、输出链表中内容12345678910111213/** * 输出链表中内容 * @param L */void PrintList(LinkedList L)&#123; // 指向链表中第一个元素 LinkedList p = L-&gt;next; // 循环至表尾 while (p)&#123; std::cout&lt;&lt; p-&gt;data &lt;&lt;" "; p = p-&gt;next; &#125;&#125; 参考资料 大话数据结构&emsp;2019-05-23]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
        <tag>链式存储结构</tag>
        <tag>单链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-静态链表]]></title>
    <url>%2F2019%2F05%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据结构-静态链表1、静态链表的简介 &emsp;&emsp;在一些早期的编程语言，由于没有指针的概念，有人想到了用数组来实现单链表的方法，改进了顺序存储结构中插入和删除操作需要移动大量元素的缺点。实现逻辑简单来说，是让数组的元素由两个数据域组成，data和cur。数组的每个下标都对应一个数据存放域data和一个游标cur。游标cur相当于单链表中的next指针，存放该元素的后继在数组中的下标，从而用游标来记录每个元素的顺序。所以，用数组描述的链表叫做静态链表。 2、静态链表的存储结构1234567#define MAXSIZE 20#define ElemType inttypedef struct &#123; ElemType data; int cur;&#125; StaticLinkedList[MAXSIZE]; 3、静态链表的初始化 当静态链表为空时，头结点指向的备用链表的第一个元素(也就是空结点链表)下标为1，尾结点指向的第一个插入元素下标为0。 当静态链表装填了6个数据时，头结点指向的备用链表的第一个元素(也就是空结点链表)下标为7，尾结点指向的第一个插入元素下标为1。 123456789101112131415161718192021/*** 初始化静态链表* 例:* 下标 0 1 2 3 4 5 6 7 8 9* 游标 1 2 3 4 5 6 7 8 9 0* 数据 头 - - - - - - - - 尾* 其中 头结点、尾结点、空结点数据为空* 头结点的游标cur存放备用链表第一个结点的下标* 尾结点的游标cur存放第一个插入元素的下标* @param space* @return Status*/Status InitList(StaticLinkedList space) &#123; for (int i = 0; i &lt; MAXSIZE - 1; i++)&#123; space[i].cur = i + 1; space[i].data = 0; &#125; space[MAXSIZE - 1].cur = 0; return OK;&#125; 4、静态链表的插入 当一个新元素被填装到静态链表里，通过插入位置前置元素游标和新元素游标的改变，使得该元素被连接到静态链表的任意位置中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/*** 取得StaticLinkedList的长度* @param L* @return int Length*/int Length(StaticLinkedList L)&#123; int j = 0; // 从尾结点获取第一个有元素的结点 int i = L[MAXSIZE - 1].cur; // 遍历计数 while (i) &#123; i = L[i].cur; j++; &#125; return j;&#125;/*** 若备用空间链表非空,则返回分配的结点下标,否则返回0* 例:* 下标 0 1 2 3 4 5 6 7 8 9* 游标 4 2 3 4 0 6 7 8 9 1* 数据 头 + + + + - - - - 尾* @param space* @return 分配的链表下标*/int Malloc_SLL(StaticLinkedList space) &#123; int i = space[0].cur; // 当前数组第一个元素cur存的值,即链表总长的下个元素的下标 if (space[0].cur) // 判断是否为链表尾 space[0].cur = space[i].cur; // 将这个空间分量分配出去,并取下个分量备用 return i;&#125;/*** 在L中第i个元素之前插入新的数据元素e* 例(插入前):* 下标 0 1 2 3 4 5 6 7 8 9* 游标 4 2 3 4 0 6 7 8 9 1* 数据 头 + + + + - - - - 尾* 例(插入后, i=3):* |----------&gt;|(2-&gt;5)* 下标 0 1 2 3 4 5 6 7 8 9* 游标 4 2 5 4 0 6 7 8 9 1* 数据 头 + + + + * - - - 尾* |&lt;------|(5-&gt;3)* @param L* @param i 在下标为i的元素前,插入一个新的元素* @param e 新元素* @return Status*/Status Insert(StaticLinkedList L, int i, ElemType e) &#123; //判断是否越界 if (i &lt; 1 || i &gt; Length(L) + 1) &#123; return ERROR; &#125; int j = Malloc_SLL(L); //尾结点下标 int k = MAXSIZE - 1; if (j) &#123; // 为新元素赋值 L[j].data = e; // 找到插入元素的前一个元素的游标 for (int l = 1; l &lt;= i - 1; l++) k = L[k].cur; /* * 简单的来说 * ① | ② | ③ * ① 是插入元素前的元素,下标为k,下一元素下标为L[k].cur * ② 是新插入元素,下标为j,下一元素下标为L[j].cur * ③ 是插入元素后的元素,即插入前在①的下一位,插入后在②的下一位,下标为L[k].cur */ L[j].cur = L[k].cur; // 将②的游标定为③ L[k].cur = j; // 将①的游标定为 return OK; &#125; return ERROR;&#125; 5、静态链表的删除 当一个元素从静态链表删除时，通过删除位置前置元素游标和删除元素游标的改变，使得该元素被从静态链表中解除，并将该删除元素使用头插法连接到头结点索引的备用链表中。该元素会在分配空间向量时优先被使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/*** 取得StaticLinkedList的长度* @param L* @return int Length*/int Length(StaticLinkedList L)&#123; int j = 0; // 从尾结点获取第一个有元素的结点 int i = L[MAXSIZE - 1].cur; // 遍历计数 while (i) &#123; i = L[i].cur; j++; &#125; return j;&#125;/*** 将下标为k的空闲结点回收到到备用链表* 也就是将删除数据后的空结点直接排在头结点后,并将之前的第一个空结点排在它之后* @param space* @param k 删除下标为k的元素*/void Free_SSL(StaticLinkedList space, int k) &#123; space[k].cur = space[0].cur; space[0].cur = k;&#125;/*** 删除下标为i的结点* 在L中第i个元素之前插入新的数据元素e* 例(删除前):* |-------------------------------&gt;|(头结点指向第一个空结点)* 下标 0 1 2 3 4 5 6 7 8 9* 游标 8 2 7 4 0 6 0 3 9 1* 数据 头 + + + + + + * - 尾* 例(删除后, i=1):* |---&gt;|(头结点先指向删除后的备用结点)* |&lt;--------------------------|(尾结点指向第一个非空的结点)* 下标 0 1 2 3 4 5 6 7 8 9* 游标 1 8 7 4 5 6 0 3 9 2* 数据 头 - + + + + + * - 尾* |--------------------------&gt;|(头结点的后继元素再指向删除前的第一个空结点)* @param L* @param i 删除第i个结点* @return*/Status Delete(StaticLinkedList L, int i) &#123; int j; // 判断是否越界 if (i &lt; 1 || i &gt; Length(L)) return ERROR; // 尾结点下标 int k = MAXSIZE - 1; //k = 第i-1个元素的下标 for (j = 1; j &lt;= i - 1; j++) k = L[k].cur; // j = 第i个元素的下标 // 解除第i个元素前后索引 j = L[k].cur; L[k].cur = L[j].cur; // 回收空结点 L[j].data = - 1; Free_SSL(L, j); return OK;&#125; 6、静态链表优缺点 优点:&emsp;在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了顺序存储结构中插入和删除操作需要移动大量元素的缺点。 缺点:&emsp;没有解决连续存储分配带来的表长难以确定的问题；失去了顺序存储结构随机存取的特性。 参考资料 大话数据结构&emsp;2019-05-20]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
        <tag>链式存储结构</tag>
        <tag>静态链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-线性表]]></title>
    <url>%2F2019%2F05%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据结构-线性表1、线性表的定义 零个或多个数据元素的优先序列。若将线性表记为(a1, … ai-1, ai, ai+1, … an)，则表中 ai-1 领先于 ai, ai 领先于 ai+1，称 ai-1 是 ai 的直接前驱元素，ai+1 是 ai 的直接后继元素。当 i=1，2，3，…，n时，ai有且仅有一个直接前驱。所以线性表元素的个数n（n&gt;0）定义为线性表长度，当 n=0 时，称为空表。 2、线性表的抽象数据类型 ADT 线性表(List) Data 线性表的数据对象集合为{a1, .. an}。每个元素的类型均为DataType。其中，除第一个元素a1外，每一个有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系时一对一的关系。 Operation Description InitList(*L) 初始化操作，建立一个空的线性表L IsEmpty(L) 若线性表为空，返回TRUE，否则返回FALSE Length(L) 返回线性表L的元素个数 Clear(*L) 将线性表清空 GetElement(L, i, *e) 将线性表L中的第i个位置元素值返回给e LocateElement(L, e) 在线性表L中寻找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败。 Insert(*L, i, e) 在线性表L中第i个位置插入新元素e Delete(L, i, e) 删除线性表L中]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
</search>
