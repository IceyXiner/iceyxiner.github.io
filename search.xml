<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构-链式栈]]></title>
    <url>%2F2019%2F06%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E5%BC%8F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[数据结构-链式栈1、链式栈的简介 &emsp;&emsp;栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。 2、链式栈的存储结构 1234567891011121314typedef SElemtype int// 栈结点typedef struct StackNode &#123; SElemtype data; struct StackNode *next;&#125; StackNode, *LinkedStackPtr;// 栈顶结构typedef struct LinkedStack &#123; // 栈顶指针 LinkedStackPtr top; // 栈内元素个数 int count = 0;&#125; LinkedStack; 3、链式栈的初始化123456789101112131415161718192021/** * 初始化栈内元素 * @param S 栈顶指针 * @param n 初始化元素个数 */void InitLinkedStack(LinkedStack *S, int n) &#123; // 定义栈顶指针 LinkedStackPtr p; // 初始化随机种子 srand(time_t(0)); // LOOP for (int i = 0; i &lt; n; ++i) &#123; // 给栈结点分配内存空间 p = (LinkedStackPtr) malloc(sizeof(StackNode)); p-&gt;data = rand() % 100 + 1; // 压栈 p-&gt;next = S-&gt;top; S-&gt;top = p; &#125; S-&gt;count = n;&#125; 4、链式栈的插入（压栈，入栈） 12345678910111213141516/** * 压栈 * @param S 栈顶指针 * @param e 压入栈的元素 * @return Status */Status Push(LinkedStack *S, SElemtype e) &#123; // 为栈节点分配内存空间 LinkedStackPtr p = (LinkedStackPtr) malloc(sizeof(StackNode)); p-&gt;data = e; // 压栈 p-&gt;next = S-&gt;top; S-&gt;count++; S-&gt;top = p; return OK;&#125; 5、链式栈的删除（弹栈、出栈） 1234567891011121314151617181920212223/** * 弹栈 * @param S 栈顶指针 * @param e 弹出元素 * @return Status */Status Pop(LinkedStack *S, SElemtype *e = nullptr) &#123; LinkedStackPtr p; // 判断栈是否为空，空则不执行弹栈操作 if (!S-&gt;count) &#123; return ERROR; &#125; // 判断弹出元素地址是否为空，空则不执行赋值操作 if (e) *e = S-&gt;top-&gt;data; // 弹栈 p = S-&gt;top; S-&gt;top = S-&gt;top-&gt;next; S-&gt;count--; // 释放空间 free(p); return OK;&#125; 6、链式栈的清空123456789101112131415/** * 清空栈中内容 * @param S 栈顶指针 */void ClearLinkedStack(LinkedStack *S) &#123; LinkedStackPtr p; for (int i = 0; i &lt; S-&gt;count; ++i) &#123; // 循环删除结点，释放内存 p = S-&gt;top; S-&gt;top = S-&gt;top-&gt;next; free(p); &#125; // 计数器置零 S-&gt;count = 0;&#125; 7、获取栈中的元素123SElemtype GetLinkedStackTop(LinkedStack S) &#123; return S.top-&gt;data;&#125; 8、判断栈是否为空123bool IsEmpty(LinkedStack S) &#123; return !S.count;&#125; 9、栈的长度123int Length(LinkedStack S) &#123; return S.count;&#125; 10、输出栈中内容1234567891011121314/** * 输出栈中内容 * @param S 栈顶指针 */void PrintStack(LinkedStack S) &#123; // 指针指向栈顶 LinkedStackPtr ptr = S.top; // 循环输出 while (ptr) &#123; std::cout &lt;&lt; ptr-&gt;data &lt;&lt; " "; ptr = ptr-&gt;next; &#125; std::cout &lt;&lt; std::endl;&#125; 参考资料 大话数据结构&emsp;2019-06-10]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链式存储结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-静态栈]]></title>
    <url>%2F2019%2F06%2F06%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%99%E6%80%81%E6%A0%88%2F</url>
    <content type="text"><![CDATA[数据结构-静态栈1、静态栈的简介 &emsp;&emsp;栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。 2、静态栈的存储结构 1234567#define MAXSIZE 20typedef int SElemType;typedef struct &#123; SElemType data[MAXSIZE]; int top; // 栈顶指针&#125; StaticStack; 3、静态栈的初始化123456789101112/** * 初始化栈内元素 * @param S 栈顶指针 */void InitStack(StaticStack *S) &#123; for (int i = 0; i &lt; MAXSIZE - 1; ++i) &#123; // 整体初始化 S-&gt;data[i] = 0; &#125; // 栈顶指针指向标志值-1 S-&gt;top = -1;&#125; 4、静态栈的插入（压栈，入栈） 12345678910111213141516/** * 压栈 * @param S 栈顶指针 * @param e 压入栈的元素 * @return Status */Status Push(StaticStack *S, SElemType e) &#123; // 如果栈满,返回失败状态 if (S-&gt;top == MAXSIZE - 1) return ERROR; // 压栈,指针上升一位 S-&gt;top++; // 赋值 S-&gt;data[S-&gt;top] = e; return OK;&#125; 5、静态栈的删除（弹栈、出栈）12345678910111213141516/** * 弹栈 * @param S 栈顶指针 * @param e 弹出元素 * @return Status */Status Pop(StaticStack *S, SElemType *e) &#123; // 判断是否为栈底,是则返回失败状态 if (S-&gt;top == -1) return ERROR; // 取出弹出元素 *e = S-&gt;data[|S-&gt;top]; // 栈顶指针下降一位 S-&gt;top--; return OK;&#125; 6、静态栈的清空123void ClearStack(StaticStack S) &#123; S.top = -1;&#125; 7、获取栈中的元素123456Status GetTop(StaticStack S, SElemType *e) &#123; if (S.top == -1) return ERROR; *e = S.data[S.top]; return OK;&#125; 8、判断栈是否为空123bool IsEmpty(StaticStack S) &#123; return S.top == -1;&#125; 9、栈的长度123int Length(StaticStack S) &#123; return S.top + 1;&#125; 10、输出栈中内容12345678910/** * 输出栈中内容 * @param S 栈顶指针 */void PrintStack(StaticStack S) &#123; for (int i = S.top; i &gt;= 0; --i) &#123; std::cout &lt;&lt; S.data[i] &lt;&lt; " "; &#125; std::cout &lt;&lt; std::endl;&#125; 参考资料 大话数据结构&emsp;2019-06-06]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>顺序存储结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-栈]]></title>
    <url>%2F2019%2F06%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%2F</url>
    <content type="text"><![CDATA[数据结构-栈1、栈的定义 &emsp;&emsp;栈是限定仅在表尾进行插入和删除操作的线性表。我们把允许插入和删除的一端称为栈顶, 另一端称为栈底, 不含任何数据元素的栈称为空栈。栈又称为后进先出(Last In First Out)的线性表，简称LIFO结构。 2、栈的基本操作2.1 栈的插入操作(压栈、入栈) 2.2 栈的删除操作(弹栈、出栈) 3、栈的抽象数据类型 ADT 栈{stack) Data 同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。 Operation Description InitStack(*S) 初始化操作，建立一个空栈S DestroyStack(*S) 若栈存在，则销毁它 ClearStack(*S) 将栈清空 GetStackTop(S, *e) 若栈存在且非空，用e返回s的栈顶元素 Push(*s, e) 若栈S存在， 插入新元素e到栈S中并成为栈项元素g Pop(S, e) 删除栈s中栈顶元素，并用e返回其值 IsEmpty(S) 若栈为空，返回TRUE，否则返回FALSE Length(S) 返回栈s的元素个数]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-双向链表]]></title>
    <url>%2F2019%2F05%2F30%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据结构-双向链表1、双向链表简介 &emsp;&emsp;双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。 2、双向链表的存储结构 123456typedef int ElemType;typedef struct Node &#123; ElemType data; struct Node *next;&#125; Node, *LinkedList; 3、双向链表的初始化3.1、头插法123456789101112131415161718192021222324252627/** * 随即产生n个元素的值,建立带表头结点的双向链表L * 头插法 * @param L 链表头结点地址 * @param n 生成链表长度 */void CreateListHead(DuLinkedList *L, int n) &#123; DuLinkedList newNode; srand(time(0)); // 初始化随机数种子 // 初始化空链表L *L = (DuLinkedList) malloc(sizeof(DulNode)); (*L)-&gt;prior = nullptr; (*L)-&gt;next = nullptr; // 循环生成链表结点 for (int i = 0; i &lt; n; i++) &#123; // 为新链表结点分配一个地址 newNode = (DuLinkedList) malloc(sizeof(DulNode)); // 初始化新链表结点中的域,随机生成100以内的数字 newNode-&gt;data = rand() % 100 + 1; // 将新链表结点插入到头结点与前一新结点之间 newNode-&gt;next = (*L)-&gt;next; if (i &gt;= 1) (*L)-&gt;next-&gt;prior = newNode; // 头结点不需要此步操作 (*L)-&gt;next = newNode; newNode-&gt;prior = *L; &#125;&#125; 3.2、尾插法12345678910111213141516171819202122232425262728293031/** * 随即产生n个元素的值,建立带表头结点的双向链表L * 尾插法 * @param L 链表头结点地址 * @param n 生成链表长度 */void CreateListTail(DuLinkedList *L, int n) &#123; DuLinkedList newNode, tailNode; srand(time(0)); // 初始化随机数种子 // 初始化空链表L *L = (DuLinkedList) malloc(sizeof(DulNode)); (*L)-&gt;prior = nullptr; // 指向尾部的结点 tailNode = *L; // 循环生成链表结点 for (int i = 0; i &lt; n; i++) &#123; // 为新链表结点分配一个地址 newNode = (DuLinkedList) malloc(sizeof(DulNode)); // 初始化新链表结点中的域,随机生成100以内的数字 newNode-&gt;data = rand() % 100 + 1; // 将链表尾部终端结点的指针指向新结点 tailNode-&gt;next = newNode; // 将新结点的前置指针指向链表尾部终端结点 newNode-&gt;prior = tailNode; // 将当前新结点定义为链表尾部终端结点 tailNode = newNode; &#125; // 当前链表尾部为NULL,链表结束 tailNode-&gt;next = nullptr;&#125; 4、获取链表内指定位置数据元素12345678910111213141516171819202122232425/** * 获取链表中的第i个元素 * 最坏时间复杂度O(n) * @param L 链表头结点地址 * @param i 第i个元素 * @param e 第i个元素的数据域 * @return */Status GetElement(DuLinkedList L, int i, ElemType *e) &#123; // 遍历计数器设置为1 int j = 1; // 获取第一个元素节点 DuLinkedList p = L-&gt;next; // 遍历链表 while (p &amp;&amp; j &lt; i) &#123; p = p-&gt;next; j++; &#125; // 判断条件 if (!p || j &gt; i) &#123; return ERROR; &#125; *e = p-&gt;data; return OK;&#125; 5、在链表内指定位置插入数据元素 123456789101112131415161718192021222324252627282930313233343536/** * 在L中的第i个位置前插入新数据元素e,L的长度加1 * 时间复杂度O(1) * @param L 链表头结点地址 * @param i 第i个位置 * @param e 新数据元素 * @return Status */Status Insert(DuLinkedList *L, int n, ElemType e) &#123; // 遍历计数器设置为1 int i = 1; // 获取头结点 DuLinkedList p = *L; // 遍历查找第i个元素 while (p &amp;&amp; i &lt; n) &#123; p = p-&gt;next; i++; &#125; // 第i个元素不存在 if (!p || i &gt; n) &#123; return ERROR; &#125; // 创建新结点并为之分配内存 DuLinkedList newNode = (DuLinkedList) malloc(sizeof(DulNode)); // 为新结点初始化数据 newNode-&gt;data = e; // 将新结点的后继结点设置为插入位置后的结点 newNode-&gt;next = p-&gt;next; // 将插入位置后的结点的前驱结点定义为新结点 p-&gt;next-&gt;prior = newNode; // 将插入位置前的结点的后继结点定义为新结点 p-&gt;next = newNode; // 将新结点的前驱结点设置为插入位置前的结点 newNode-&gt;prior = p; return OK;&#125; 6、在链表内删除指定位置的数据元素 1234567891011121314151617181920212223242526272829303132333435/** * 删除L中的第i个数据元素,并用e返回其值,L的长度减1 * 时间复杂度O(1) * @param L 链表头结点地址 * @param i 第i个位置 * @param e 被删除的数据元素 * @return Status */Status Delete(DuLinkedList *L, int n, ElemType *e) &#123; // 遍历计数器设置为1 int i = 1; // 获取头节点 DuLinkedList p = *L, q; // 遍历查找第i个元素 while (p &amp;&amp; i &lt; n) &#123; p = p-&gt;next; i++; &#125; // 第i个元素不存在 if (!p || i &gt; n) &#123; return ERROR; &#125; // 将q指针指向为第i个元素,此时p指针指向第i-1个元素,q指针指向第i个元素 q = p-&gt;next; // 将p(第i-1个元素)的后继元素定义为q(第i个元素)的后继元素 // 将q(第i个元素)的后继元素的前驱元素定义为p(第i-1个元素) // 即空开第i个元素,将第i-1个元素和第i个元素相连 p-&gt;next = q-&gt;next; q-&gt;next-&gt;prior = p; // e返回删除元素的数据域 *e = q-&gt;data; // free函数回收q所占用的内存 free(q); return OK;&#125; 7、清空链表123456789101112131415161718192021/** * 将L重置为空表 * @param L 链表头结点地址 * @return Status */Status Clear(DuLinkedList *L) &#123; DuLinkedList p, q; // p指针指向第一个结点 p = (*L)-&gt;next; // 循环直至表尾 while (p) &#123; // q指针记录p的下一个结点 // 如果无此变量,释放p后,无法找到下个元素 q = p-&gt;next; free(p); p = q; &#125; // 头结点指针域为NULL (*L)-&gt;next = nullptr; return OK;&#125; 8、输出链表中内容12345678910111213141516171819202122232425262728/** * 输出链表中内容 * @param L 链表 * @param n 从第n个元素开始 * @param is_asc 是否顺序输出: true-顺序输出(默认),false-逆序输出 */void PrintList(DuLinkedList L, int n, bool is_asc = true) &#123; int i = 1; DuLinkedList p = L-&gt;next; while (p &amp;&amp; i &lt; n) &#123; p = p-&gt;next; i++; &#125; if (is_asc) &#123; // 循环至表尾 while (p) &#123; std::cout &lt;&lt; p-&gt;data &lt;&lt; " "; p = p-&gt;next; &#125; &#125; else &#123; // 循环至表头 while (p-&gt;prior) &#123; std::cout &lt;&lt; p-&gt;data &lt;&lt; " "; p = p-&gt;prior; &#125; &#125; std::cout &lt;&lt; std::endl;&#125; 参考资料 大话数据结构&emsp;2019-05-30]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
        <tag>链式存储结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-循环链表]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据结构-循环链表1、循环链表简介 &emsp;&emsp;循环链表是另一种形式的链式存贮结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。 2、循环链表的存储结构123456typedef int ElemType;typedef struct Node &#123; int data; struct Node *next;&#125; Node, *CircularLinkedList; 3、循环链表的初始化3.1、头插法123456789101112131415161718192021222324/** * 随即产生n个元素的值,建立循环链表L * 头插法 -- 即倒序填装 * @param L 单链表头结点地址 * @param n 生成链表长度 */void CreateListHead(CircularLinkedList *L, int n) &#123; CircularLinkedList newNode; srand(time_t(0)); // 初始化随机数种子 // 初始化循环链表的第一个结点 *L = (CircularLinkedList) malloc(sizeof(Node)); (*L)-&gt;data = rand() % 100 + 1; (*L)-&gt;next = *L; // 循环生成链表结点 for (int i = 1; i &lt; n; i++) &#123; // 为新链表结点分配一个地址 newNode = (CircularLinkedList) malloc(sizeof(Node)); // 初始化新链表结点中的域,随机生成100以内的数字 newNode-&gt;data = rand() % 100 + 1; // 将新链表结点插入到头结点与前一新结点之间 newNode-&gt;next = (*L)-&gt;next; (*L)-&gt;next = newNode; &#125;&#125; 3.2、尾插法12345678910111213141516171819202122232425262728/** * 随即产生n个元素的值,建立循环链表L * 尾插法 -- 即顺序填装 * @param L 循环链表头结点地址 * @param n 生成链表长度 */void CreateListTail(CircularLinkedList *L, int n) &#123; CircularLinkedList tailNode, newNode; srand(time_t(0)); // 初始化随机数种子 // 初始化循环链表的第一个结点 *L = (CircularLinkedList) malloc(sizeof(Node)); (*L)-&gt;data = rand() % 100 + 1; // 指向尾部的结点 tailNode = *L; // 循环生成链表结点 for (int i = 1; i &lt; n; i++) &#123; // 为新链表结点分配一个地址 newNode = (CircularLinkedList) malloc(sizeof(Node)); // 初始化新链表结点中的域,随机生成100以内的数字 newNode-&gt;data = rand() % 100 + 1; // 将链表尾部终端结点的指针指向新结点 tailNode-&gt;next = newNode; // 将当前新结点定义为链表尾部终端结点 tailNode = newNode; &#125; // 将链表尾部连接到头部 tailNode-&gt;next = *L;&#125; 4、在链表内指定位置插入数据元素12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 在L中的第i个位置前插入新数据元素e,L的长度加1 * 时间复杂度O(1) * @param L 链表头结点地址 * @param i 第i个位置 * @param e 新数据元素 * @return Status */Status Insert(CircularLinkedList *L, int i, ElemType e) &#123; CircularLinkedList p = *L, s; // 对于循环链表,因为头结点相对特殊,需要单独处理 // 即在头结点前插入元素后,将表头结点地址更改为新插入结点地址 if (i == 1) &#123; // 将p指针指向链表最后一个元素 for (; p-&gt;next != *L; p = p-&gt;next); // 创建新结点并为之分配内存 s = (CircularLinkedList) malloc(sizeof(Node)); // 为新结点初始化数据 s-&gt;data = e; // 将新结点的后继结点设置为插入位置后的结点(即之前的头结点) s-&gt;next = p-&gt;next; // 前驱结点设置为插入位置前的结点(即尾结点) p-&gt;next = s; //将表头结点地址更改为新插入结点地址 *L = s; &#125; else &#123; int j = 1; // 遍历查找第i个元素 for (;p-&gt;next != *L &amp;&amp; j &lt; i - 1;p = p-&gt;next, ++j); // 第i个元素不存在 if (p == *L &amp;&amp; j &gt; i) return ERROR; // 创建新结点并为之分配内存 s = (CircularLinkedList) malloc(sizeof(Node)); // 为新结点初始化数据 s-&gt;data = e; // 将新结点的后继结点设置为插入位置后的结点 s-&gt;next = p-&gt;next; // 前驱结点设置为插入位置前的结点 p-&gt;next = s; &#125; return OK;&#125; 5、在链表内删除指定位置的数据元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 删除L中的第i个数据元素,并用e返回其值,L的长度减1 * 时间复杂度O(1) * @param L 链表头结点地址 * @param i 第i个位置 * @param e 被删除的数据元素 * @return Status */Status Delete(CircularLinkedList *L, int i, ElemType *e) &#123; CircularLinkedList p = *L, q; if (i == 1)&#123; // q指针指向第二个结点 q = p-&gt;next; // 遍历到链表尾 for (; p-&gt;next != *L; p = p-&gt;next); // 将p(尾结点)的后继元素定义为q(第1个元素)的后继元素 // 即空开第1个元素,将第i个元素和第2个元素相连 p-&gt;next = q; // 重新将p指针指向被孤立的元素(即马上被删掉的头结点) p = *L; // e返回删除元素的数据域 *e = p-&gt;data; // 将头结点移动到第二个元素结点 *L = q; // free函数回收q所占用的内存 free(p); &#125; else &#123; // 遍历计数器设置为2(从第二个开始) int j = 2; // 获取头节点 CircularLinkedList p = *L, q; // 遍历查找第i个元素 for (;p-&gt;next != *L &amp;&amp; j &lt; i;p = p-&gt;next, ++j); // 第i个元素不存在 if (i &gt;= j) return ERROR; // 将q指针指向为第i个元素,此时p指针指向第i-1个元素,q指针指向第i个元素 q = p-&gt;next; // 将p(第i-1个元素)的后继元素定义为q(第i个元素)的后继元素 // 即空开第i个元素,将第i-1个元素和第i个元素相连 p-&gt;next = q-&gt;next; // e返回删除元素的数据域 *e = q-&gt;data; // free函数回收q所占用的内存 free(q); &#125; return OK;&#125; 6、打印链表中内容12345678void PrintList(CircularLinkedList L) &#123; CircularLinkedList target = L; do &#123; std::cout &lt;&lt; target-&gt;data &lt;&lt; " "; target = target-&gt;next; &#125; while ((target != L)); // 防止无限循环下去 std::cout &lt;&lt; std::endl;&#125; 参考资料 大话数据结构&emsp;2019-05-26]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
        <tag>链式存储结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-单链表]]></title>
    <url>%2F2019%2F05%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据结构-单链表1、单链表简介1.1、概念介绍 &emsp;&emsp;链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象) + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。以“结点的序列”表示线性表称作线性链表（属于链式存储结构的线性表）。 1.2、链接存储方法的具体存储表示 ① 用一组任意的存储单元来存放线性表的结点（这组存储单元既可以是连续的，也可以是不连续的） ② 链表中结点的逻辑次序和物理次序不一定相同。为了能正确表示结点间的逻辑关系，在存储每个结点值的同时，还必须存储指示其后继结点的地址信息。 2、单链表的存储结构123456typedef int ElemType;typedef struct Node &#123; ElemType data; struct Node *next;&#125; Node, *LinkedList; 3、单链表的初始化3.1、头插法 123456789101112131415161718192021222324/** * 随即产生n个元素的值,建立带表头结点的单链表L * 头插法 * @param L 链表头结点地址 * @param n 生成链表长度 */void CreateListHead(LinkedList *L, int n) &#123; LinkedList newNode; srand(time_t(0)); // 初始化随机数种子 // 初始化一个空链表L *L = (LinkedList) malloc(sizeof(Node)); (*L)-&gt;next = nullptr; // 循环生成链表结点 for (int i = 0; i &lt; n; i++) &#123; // 为新链表结点分配一个地址 newNode = (LinkedList) malloc(sizeof(Node)); // 初始化新链表结点中的域,随机生成100以内的数字 newNode-&gt;data = rand() % 100 + 1; // 将新链表结点插入到头结点与前一新结点之间 newNode-&gt;next = (*L)-&gt;next; (*L)-&gt;next = newNode; &#125;&#125; 3.2、尾插法123456789101112131415161718192021222324252627/** * 随即产生n个元素的值,建立带表头结点的单链表L * 尾插法 * @param L 链表头结点地址 * @param n 生成链表长度 */void CreateListTail(LinkedList *L, int n) &#123; LinkedList tailNode, newNode; srand(time_t(0)); // 初始化随机数种子 // 初始化一个空链表L *L = (LinkedList) malloc(sizeof(Node)); // 指向尾部的结点 tailNode = *L; // 循环生成链表结点 for (int i = 0; i &lt; n; i++) &#123; // 为新链表结点分配一个地址 newNode = (LinkedList) malloc(sizeof(Node)); // 初始化新链表结点中的域,随机生成100以内的数字 newNode-&gt;data = rand() % 100 + 1; // 将链表尾部终端结点的指针指向新结点 tailNode-&gt;next = newNode; // 将当前新结点定义为链表尾部终端结点 tailNode = newNode; &#125; // 当前链表尾部为NULL,链表结束 tailNode-&gt;next = nullptr;&#125; 4、获取链表内指定位置数据元素123456789101112131415161718192021222324/** * 获取链表中的第i个元素 * 最坏时间复杂度O(n) * @param L 链表头结点地址 * @param i 第i个元素 * @param e 第i个元素的数据域 * @return */Status GetElement(LinkedList L, int i, ElemType *e) &#123; // 遍历计数器设置为1 int j = 1; // 获取第一个元素节点 LinkedList p = L-&gt;next; // 遍历链表 while (p &amp;&amp; j &lt; i) &#123; p = p-&gt;next; j++; &#125; // 判断条件 if (!p || j &gt; i) return ERROR; *e = p-&gt;data; return OK;&#125; 5、在链表内指定位置插入数据元素 12345678910111213141516171819202122232425262728293031/** * 在L中的第i个位置前插入新数据元素e,L的长度加1 * 时间复杂度O(1) * @param L 链表头结点地址 * @param i 第i个位置 * @param e 新数据元素 * @return Status */Status Insert(LinkedList *L, int i, ElemType e) &#123; // 遍历计数器设置为1 int j = 1; // 获取头结点 LinkedList p = *L; // 遍历查找第i个元素 while (p &amp;&amp; j &lt; i) &#123; p = p-&gt;next; ++j; &#125; // 第i个元素不存在 if (!p &amp;&amp; j &gt; i) return ERROR; // 创建新结点并为之分配内存 LinkedList s = (LinkedList) malloc(sizeof(Node)); // 为新结点初始化数据 s-&gt;data = e; // 将新结点的后继结点设置为插入位置后的结点 s-&gt;next = p-&gt;next; // 前驱结点设置为插入位置前的结点 p-&gt;next = s; return OK;&#125; 6、在链表内删除指定位置的数据元素 1234567891011121314151617181920212223242526272829303132/** * 删除L中的第i个数据元素,并用e返回其值,L的长度减1 * 时间复杂度O(1) * @param L 链表头结点地址 * @param i 第i个位置 * @param e 被删除的数据元素 * @return Status */Status Delete(LinkedList *L, int i, ElemType *e) &#123; // 遍历计数器设置为1 int j = 1; // 获取头节点 LinkedList p = *L, q; // 遍历查找第i个元素 while (p-&gt;next &amp;&amp; j &lt; i) &#123; p = p-&gt;next; ++j; &#125; // 第i个元素不存在 if (!(p-&gt;next) || j &gt; i) return ERROR; // 将q指针指向为第i个元素,此时p指针指向第i-1个元素,q指针指向第i个元素 q = p-&gt;next; // 将p(第i-1个元素)的后继元素定义为q(第i个元素)的后继元素 // 即空开第i个元素,将第i-1个元素和第i个元素相连 p-&gt;next = q-&gt;next; // e返回删除元素的数据域 *e = q-&gt;data; // free函数回收q所占用的内存 free(q); return OK;&#125; 7、清空链表123456789101112131415161718192021/** * 将L重置为空表 * @param L 链表头结点地址 * @return Status */Status Clear(LinkedList *L) &#123; LinkedList p, q; // p指针指向第一个结点 p = (*L)-&gt;next; // 循环直至表尾 while (p) &#123; // q指针记录p的下一个结点 // 如果无此变量,释放p后,无法找到下个元素 q = p-&gt;next; free(p); p = q; &#125; // 头结点指针域为NULL (*L)-&gt;next = nullptr; return OK;&#125; 8、输出链表中内容12345678910111213/** * 输出链表中内容 * @param L */void PrintList(LinkedList L)&#123; // 指向链表中第一个元素 LinkedList p = L-&gt;next; // 循环至表尾 while (p)&#123; std::cout&lt;&lt; p-&gt;data &lt;&lt;" "; p = p-&gt;next; &#125;&#125; 参考资料 大话数据结构&emsp;2019-05-23]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
        <tag>链式存储结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-静态链表]]></title>
    <url>%2F2019%2F05%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据结构-静态链表1、静态链表的简介 &emsp;&emsp;在一些早期的编程语言，由于没有指针的概念，有人想到了用数组来实现单链表的方法，改进了顺序存储结构中插入和删除操作需要移动大量元素的缺点。实现逻辑简单来说，是让数组的元素由两个数据域组成，data和cur。数组的每个下标都对应一个数据存放域data和一个游标cur。游标cur相当于单链表中的next指针，存放该元素的后继在数组中的下标，从而用游标来记录每个元素的顺序。所以，用数组描述的链表叫做静态链表。 2、静态链表的存储结构1234567#define MAXSIZE 20#define ElemType inttypedef struct &#123; ElemType data; int cur;&#125; StaticLinkedList[MAXSIZE]; 3、静态链表的初始化 当静态链表为空时，头结点指向的备用链表的第一个元素(也就是空结点链表)下标为1，尾结点指向的第一个插入元素下标为0。 当静态链表装填了6个数据时，头结点指向的备用链表的第一个元素(也就是空结点链表)下标为7，尾结点指向的第一个插入元素下标为1。 123456789101112131415161718192021/*** 初始化静态链表* 例:* 下标 0 1 2 3 4 5 6 7 8 9* 游标 1 2 3 4 5 6 7 8 9 0* 数据 头 - - - - - - - - 尾* 其中 头结点、尾结点、空结点数据为空* 头结点的游标cur存放备用链表第一个结点的下标* 尾结点的游标cur存放第一个插入元素的下标* @param space* @return Status*/Status InitList(StaticLinkedList space) &#123; for (int i = 0; i &lt; MAXSIZE - 1; i++)&#123; space[i].cur = i + 1; space[i].data = 0; &#125; space[MAXSIZE - 1].cur = 0; return OK;&#125; 4、静态链表的插入 当一个新元素被填装到静态链表里，通过插入位置前置元素游标和新元素游标的改变，使得该元素被连接到静态链表的任意位置中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/*** 取得StaticLinkedList的长度* @param L* @return int Length*/int Length(StaticLinkedList L)&#123; int j = 0; // 从尾结点获取第一个有元素的结点 int i = L[MAXSIZE - 1].cur; // 遍历计数 while (i) &#123; i = L[i].cur; j++; &#125; return j;&#125;/*** 若备用空间链表非空,则返回分配的结点下标,否则返回0* 例:* 下标 0 1 2 3 4 5 6 7 8 9* 游标 4 2 3 4 0 6 7 8 9 1* 数据 头 + + + + - - - - 尾* @param space* @return 分配的链表下标*/int Malloc_SLL(StaticLinkedList space) &#123; int i = space[0].cur; // 当前数组第一个元素cur存的值,即链表总长的下个元素的下标 if (space[0].cur) // 判断是否为链表尾 space[0].cur = space[i].cur; // 将这个空间分量分配出去,并取下个分量备用 return i;&#125;/*** 在L中第i个元素之前插入新的数据元素e* 例(插入前):* 下标 0 1 2 3 4 5 6 7 8 9* 游标 4 2 3 4 0 6 7 8 9 1* 数据 头 + + + + - - - - 尾* 例(插入后, i=3):* |----------&gt;|(2-&gt;5)* 下标 0 1 2 3 4 5 6 7 8 9* 游标 4 2 5 4 0 6 7 8 9 1* 数据 头 + + + + * - - - 尾* |&lt;------|(5-&gt;3)* @param L* @param i 在下标为i的元素前,插入一个新的元素* @param e 新元素* @return Status*/Status Insert(StaticLinkedList L, int i, ElemType e) &#123; //判断是否越界 if (i &lt; 1 || i &gt; Length(L) + 1) &#123; return ERROR; &#125; int j = Malloc_SLL(L); //尾结点下标 int k = MAXSIZE - 1; if (j) &#123; // 为新元素赋值 L[j].data = e; // 找到插入元素的前一个元素的游标 for (int l = 1; l &lt;= i - 1; l++) k = L[k].cur; /* * 简单的来说 * ① | ② | ③ * ① 是插入元素前的元素,下标为k,下一元素下标为L[k].cur * ② 是新插入元素,下标为j,下一元素下标为L[j].cur * ③ 是插入元素后的元素,即插入前在①的下一位,插入后在②的下一位,下标为L[k].cur */ L[j].cur = L[k].cur; // 将②的游标定为③ L[k].cur = j; // 将①的游标定为 return OK; &#125; return ERROR;&#125; 5、静态链表的删除 当一个元素从静态链表删除时，通过删除位置前置元素游标和删除元素游标的改变，使得该元素被从静态链表中解除，并将该删除元素使用头插法连接到头结点索引的备用链表中。该元素会在分配空间向量时优先被使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/*** 取得StaticLinkedList的长度* @param L* @return int Length*/int Length(StaticLinkedList L)&#123; int j = 0; // 从尾结点获取第一个有元素的结点 int i = L[MAXSIZE - 1].cur; // 遍历计数 while (i) &#123; i = L[i].cur; j++; &#125; return j;&#125;/*** 将下标为k的空闲结点回收到到备用链表* 也就是将删除数据后的空结点直接排在头结点后,并将之前的第一个空结点排在它之后* @param space* @param k 删除下标为k的元素*/void Free_SSL(StaticLinkedList space, int k) &#123; space[k].cur = space[0].cur; space[0].cur = k;&#125;/*** 删除下标为i的结点* 在L中第i个元素之前插入新的数据元素e* 例(删除前):* |-------------------------------&gt;|(头结点指向第一个空结点)* 下标 0 1 2 3 4 5 6 7 8 9* 游标 8 2 7 4 0 6 0 3 9 1* 数据 头 + + + + + + * - 尾* 例(删除后, i=1):* |---&gt;|(头结点先指向删除后的备用结点)* |&lt;--------------------------|(尾结点指向第一个非空的结点)* 下标 0 1 2 3 4 5 6 7 8 9* 游标 1 8 7 4 5 6 0 3 9 2* 数据 头 - + + + + + * - 尾* |--------------------------&gt;|(头结点的后继元素再指向删除前的第一个空结点)* @param L* @param i 删除第i个结点* @return*/Status Delete(StaticLinkedList L, int i) &#123; int j; // 判断是否越界 if (i &lt; 1 || i &gt; Length(L)) return ERROR; // 尾结点下标 int k = MAXSIZE - 1; //k = 第i-1个元素的下标 for (j = 1; j &lt;= i - 1; j++) k = L[k].cur; // j = 第i个元素的下标 // 解除第i个元素前后索引 j = L[k].cur; L[k].cur = L[j].cur; // 回收空结点 L[j].data = - 1; Free_SSL(L, j); return OK;&#125; 6、静态链表优缺点 优点:&emsp;在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了顺序存储结构中插入和删除操作需要移动大量元素的缺点。 缺点:&emsp;没有解决连续存储分配带来的表长难以确定的问题；失去了顺序存储结构随机存取的特性。 参考资料 大话数据结构&emsp;2019-05-20]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
        <tag>顺序存储结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-线性表]]></title>
    <url>%2F2019%2F05%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据结构-线性表1、线性表的定义 &emsp;&emsp;零个或多个数据元素的优先序列。若将线性表记为(a1, … ai-1, ai, ai+1, … an)，则表中 ai-1 领先于 ai, ai 领先于 ai+1，称 ai-1 是 ai 的直接前驱元素，ai+1 是 ai 的直接后继元素。当 i=1，2，3，…，n时，ai有且仅有一个直接前驱。所以线性表元素的个数n（n&gt;0）定义为线性表长度，当 n=0 时，称为空表。 2、线性表的抽象数据类型 ADT 线性表(List) Data 线性表的数据对象集合为{a1, .. an}。每个元素的类型均为DataType。其中，除第一个元素a1外，每一个有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系时一对一的关系。 Operation Description InitList(*L) 初始化操作，建立一个空的线性表L GetElement(L, i, *e) 将线性表L中的第i个位置元素值返回给e LocateElement(L, e) 在线性表L中寻找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败。 Insert(*L, i, e) 在线性表L中第i个位置插入新元素e Delete(L, i, e) 删除线性表L中 Clear(*L) 将线性表清空 IsEmpty(L) 若线性表为空，返回TRUE，否则返回FALSE Length(L) 返回线性表L的元素个数]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
</search>
